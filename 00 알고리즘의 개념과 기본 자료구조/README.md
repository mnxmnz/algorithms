# 🌱 알고리즘의 개념과 기본 자료구조

## 1. 그리디 알고리즘

> **현재 상황에서 지금 당장 좋은 것만 고르는 방법**

- 일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많습니다.
- **탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론할 수 있어야 풀리도록 출제하는 경우가 많습니다.**
- 그리디 알고리즘을 사용한 대표적인 문제는 거스름 돈 문제입니다.
  - 가지고 있는 동전 중 큰 단위가 항상 작은 단위의 배수라면 그리디 알고리즘을 적용할 수 있습니다.
  - 거스름 돈 800원에서 화폐 단위가 500원, 400원, 100원이면 배수 단위가 아니라서 그리디 알고리즘을 적용할 수 없습니다.

<br />

## 2. 구현

> **머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정**

- 구현 문제 예시
  1. 알고리즘은 간단한데 코드가 지나치게 길어지는 문제
  2. 실수 연산을 다루며 특정 소수점 자리까지 출력하는 문제
  3. 문자열을 특정 기준에 따라 끊어 처리하는 문제
  4. 적절한 라이브러리를 찾아서 해결해야 하는 문제
- 시뮬레이션 및 완전 탐색 문제에서는 2차원 공간에서의 **방향 벡터**가 자주 활용됩니다.

![img.png](https://user-images.githubusercontent.com/48766355/221347263-83e09856-85ab-46aa-9990-0b35668372eb.png)

<br />

## 3. DFS/BFS

> **그래프 탐색 알고리즘**

- 탐색이란 많은 양의 데이터 중에서 **원하는 데이터를 찾는 과정**입니다.

<details>

<summary>DFS/BFS 배경지식</summary>

- 스택 자료구조

  - 먼저 들어온 데이터가 나중에 나가는 형식입니다. (선입후출)
  - **입구와 출구가 동일한 형태입니다.**

- 큐 자료구조

  - 먼저 들어온 데이터가 먼저 나가는 형식입니다. (선입선출)
  - **입구와 출구가 모두 뚫려 있는 터널과 같은 형태입니다.**

- 재귀 함수
  - **자기 자신을 다시 호출하는 함수입니다.**
  - 재귀 함수의 종료 조건을 명시하는 것이 필요합니다.
  - 종료 조건을 제대로 명시하지 않으면 함수가 무한히 호출될 수 있습니다.
  - 재귀 함수를 사용한 대표적인 문제는 두 개의 자연수에 대한 최대공약수를 구하는 **유클리드 호제법**입니다.
  - 재귀 함수를 잘 활용하면 복잡한 알고리즘을 간결하게 작성할 수 있습니다. (단, 오히려 다른 사람이 이해하기 어려운 코드가 될 수도 있으므로 신중하게 사용해야 합니다.)
  - 컴퓨터가 함수를 연속적으로 호출하면 컴퓨터 메모리 내부의 스택 프레임에 쌓입니다. (스택을 사용해야 할 때 구현상 **스택 라이브러리 대신에 재귀 함수를 이용**하는 경우가 많습니다.)

</details>

### 3-1. DFS

- DFS는 **깊이 우선 탐색**이라고도 부르며 그래프에서 **깊은 부분을 우선적으로 탐색하는 알고리즘**입니다.
- DFS는 **스택 자료구조(혹은 재귀 함수)를 이용**하며, 구체적인 동작 과정은 다음과 같습니다.
  1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 합니다.
  2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문 처리합니다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냅니다.
  3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복합니다.

<details>

<summary>DFS JS 구현</summary>

```js
function dfs(graph, start) {
  const stack = [start];
  const result = [];
  const visited = {};

  visited[start] = true;

  while (stack.length) {
    const currentVertex = stack.pop();
    result.push(currentVertex);

    graph[currentVertex].forEach(neighbor => {
      if (!visited[neighbor]) {
        visited[neighbor] = true;
        stack.push(neighbor);
      }
    });
  }

  return result;
}
```

</details>

### 3-2. BFS

- BFS는 **너비 우선 탐색**이라고도 부르며, 그래프에서 **가까운 노드부터 우선적으로 탐색하는 알고리즘**입니다.
- BFS는 **큐 자료구조**를 이용하며, 구체적인 동작 과정은 다음과 같습니다.
  1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 합니다.
  2. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리합니다.
  3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복합니다.
- 최단 거리 탐색으로 사용하는 경우가 많은 알고리즘입니다.

<details>

<summary>BFS JS 구현</summary>

```js
function bfs(graph, start) {
  const queue = [start];
  const result = [];
  const visited = {};

  visited[start] = true;

  while (queue.length) {
    const currentVertex = queue.shift();
    result.push(currentVertex);

    graph[currentVertex].forEach(neighbor => {
      if (!visited[neighbor]) {
        visited[neighbor] = true;
        queue.push(neighbor);
      }
    });
  }

  return result;
}
```

</details>

<br />

## 4. 정렬 알고리즘

> **데이터를 특정한 기준에 따라 순서대로 나열**

### 4-1. 선택 정렬

- 처리되지 않은 데이터 중에서 **가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복**합니다.
- N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내는 연산이 필요하므로 O(N^2)의 시간 복잡도를 갖고 있습니다.

### 4-2. 삽입 정렬

- 처리되지 않은 데이터를 하나씩 골라 **적절한 위치에 삽입**합니다.
- 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작합니다.
- 시간 복잡도는 O(N^2)이며, 선택 정렬과 마찬가지로 반복문이 두 번 중첩되어 사용됩니다.
- 삽입 정렬은 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작합니다. 최선의 경우 O(N)의 시간 복잡도를 가집니다.

### 4-3. 퀵 정렬

- 기준 데이터를 설정하고 그 **기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법**입니다.
- 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나입니다.
- 가장 기본적인 퀵 정렬은 **첫 번째 데이터를 기준 데이터(Pivot)로 설정**합니다.
- 평균의 경우 O(NlogN)의 시간 복잡도를 가집니다. 하지만 최악의 경우 O(N^2)의 시간 복잡도를 가집니다.

### 4-4. 계수 정렬

- **데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때**만 사용할 수 있지만 **매우 빠르게 동작하는** 정렬 알고리즘입니다.
- 데이터의 개수가 N, 데이터 중 최댓값이 K일 때 최악의 경우에도 수행 시간 O(N+K)를 보장합니다. 시간 복잡도와 공간 복잡도 모두 O(N+K)입니다.
- 계수 정렬은 **동일한 값을 가지는 데이터가 여러 개 등장할 때** 효과적으로 사용할 수 있습니다. 성적의 경우 100점을 맞은 학생이 여러 명일 수 있기 때문에 계수 정렬이 효과적입니다.

| 정렬 알고리즘 | 평균 시간 복잡도 | 공간 복잡도 | 특징                                                                             |
| :-----------: | :--------------: | :---------: | -------------------------------------------------------------------------------- |
| **선택 정렬** |      O(N^2)      |    O(N)     | 아이디어가 매우 간단합니다.                                                      |
| **삽입 정렬** |      O(N^2)      |    O(N)     | 데이터가 거의 정렬되어 있을 때는 가장 빠릅니다.                                  |
|  **퀵 정렬**  |     O(NlogN)     |    O(N)     | 대부분의 경우에 가장 적합하며, 충분히 빠릅니다.                                  |
| **계수 정렬** |      O(N+K)      |   O(N+K)    | 데이터의 크기가 한정되어 있는 경우에만 사용이 가능하지만 매우 빠르게 동작합니다. |

<br />

## 5. 이진 탐색 알고리즘

> 정렬되어 있는 리스트에서 **탐색 범위를 절반씩 좁혀가며 데이터를 탐색**하는 방법

- 이진 탐색은 시작점, 끝점, 중간점을 이용하여 탐색 범위를 설정합니다.
- 이진 탐색은 탐색 범위를 절반씩 줄이며, 시간 복잡도는 O(logN)을 보장합니다.

### 5-1. 파라메트릭 서치

- **파라메트릭 서치**란 최적화 문제를 결정 문제('예' 혹은 '아니오')로 바꾸어 해결하는 기법입니다.
- 일반적으로 코딩 테스트에서 파라메트릭 서치 문제는 **이진 탐색을 이용하여 해결**할 수 있습니다.
- 큰 탐색 범위를 보면 가장 먼저 **이진 탐색**을 떠올려야 합니다.

<br />

## 6. 다이나믹 프로그래밍

> **메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법**

- 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 합니다.
- 다이나믹 프로그래밍의 구현은 일반적으로 두 가지 방식(탑다운과 바텀업)으로 구성됩니다.
- 다이나믹 프로그래밍은 **동적 계획법**이라고도 부릅니다.
- 일반적인 프로그래밍 분야에서의 동적(Dynamic)이란 어떤 의미를 가질까요?
  - 자료구조에서 동적 할당(Dynamic Allocation)은 '**프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법**'을 의미합니다.
  - 반면에 다이나믹 프로그래밍에서 '다이나믹'은 **별다른 의미 없이 사용된 단어**입니다.
- 다이나믹 프로그래밍은 문제가 다음의 조건을 만족할 때 사용할 수 있습니다.
  - **최적 부분 구조 (Optimal Substructure)**
    - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있습니다.
  - **중복되는 부분 문제 (Overlapping Subproblem)**
    - 동일한 작은 문제를 반복적으로 해결해야 합니다.

### 6-1. 피보나치 수열

- 피보나치 수열은 다음과 같은 형태의 수열이며, 다이나믹 프로그래밍으로 효과적으로 계산할 수 있습니다.
  - 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89
- 점화식이란 인접한 항들 사이의 관계식을 의미합니다.
- 피보나치 수열을 점화식으로 표현하면 다음과 같습니다.
  - a(n) = a(n-1) + a(n-2), a(1) = 1, a(2) = 1
- 피보나치 수열이 계산되는 과정은 다음과 같이 표현할 수 있습니다.
  - 프로그래밍에서는 이러한 수열을 배열이나 리스트를 이용해 표현합니다.

![img](https://user-images.githubusercontent.com/48766355/221347292-7bf9b60f-d007-4e98-b746-7772c947d848.png)

- n번째 피보나치 수를 f(n)라고 할 때 4번째 피보나치 수 f(4)를 구하는 과정은 다음과 같습니다.

![img](https://user-images.githubusercontent.com/48766355/221347309-6e4c7dfa-4566-4fdb-b268-433810a6f160.png)

### 6-2. 피보나치 수열의 시간 복잡도 분석

- 단순 재귀 함수로 피보나치 수열을 해결하면 지수 시간 복잡도를 가지게 됩니다.
- 다음과 같이 f(2)가 여러 번 호출되는 것을 확인할 수 있습니다. (**중복되는 부분 문제**)

![img](https://user-images.githubusercontent.com/48766355/221347446-af390485-3891-488b-9c94-21cbc3e34d1c.png)

- 피보나치 수열의 **시간 복잡도**는 다음과 같습니다.
  - 빅오 표기법: O(2^N)
- 빅오 표기법을 기준으로 f(30)을 계산하기 위해 약 10억 가량의 연산을 수행해야 합니다.

### 6-3. 피보나치 수열의 효율적인 해법: 다이나믹 프로그래밍

- 다이나믹 프로그래밍의 사용 **조건**을 만족하는지 확인합니다.
  - **최적 부분 구조**: 큰 문제를 작은 문제로 나눌 수 있습니다.
  - **중복되는 부분 문제**: 동일한 작은 문제를 반복적으로 해결합니다.
- 피보나치 수열은 다이나믹 프로그래밍의 사용 조건을 만족합니다.

### 6-4. 메모이제이션(Memoization)

- 메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 하나입니다.
- 한 번 계산한 결과를 메모리 공간에 메모하는 기법입니다.
  - 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옵니다.
  - 값을 기록해 놓는다는 점에서 캐싱(Caching)이라고도 합니다.

### 6-5. 탑다운 vs 바텀업

- 탑다운(메모이제이션) 방식은 **하향식**이라고도 하며 바텀업 방식은 **상향식**이라고도 합니다.
- 다이나믹 프로그래밍의 전형적인 형태는 바텀업 방식입니다.
  - 결과 저장용 리스트는 **DP 테이블**이라고 부릅니다.
- 엄밀히 말하면 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미합니다.
  - 따라서 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아닙니다.
  - 한 번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있습니다.

### 6-6. 피보나치 수열: 메모이제이션 동작 분석

- 이미 계산된 결과를 메모리에 저장하면 다음과 같이 색칠된 노드만 처리할 것을 기대할 수 있습니다.

![img](https://user-images.githubusercontent.com/48766355/221349115-ce47c69b-f807-494e-92e7-7ea5a794aad9.png)

- 실제로 호출되는 함수에 대해서만 확인해 보면 다음과 같이 방문합니다.

![img](https://user-images.githubusercontent.com/48766355/221349149-62ab9968-bb68-455c-9cf8-5beaf89709b2.png)

- 메모이제이션을 이용하는 경우 피보나치 수열 함수의 시간 복잡도는 O(N)입니다.

### 6-7. 다이나믹 프로그래밍 vs 분할 정복

- 다이나믹 프로그래밍과 분할 정복은 모두 **최적 부분 구조**를 가질 때 사용할 수 있습니다.
  - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황에 사용할 수 있습니다.
- 다이나믹 프로그래밍과 분할 정복의 차이점은 **부분 문제의 중복**입니다.
  - 다이나믹 프로그래밍 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복됩니다.
  - 분할 정복에서는 동일한 부분 문제가 반복적으로 계산되지 않습니다.
- **분할 정복**의 대표적인 예시인 퀵 정렬을 살펴봅시다.
  - 한 번 기준 원소(Pivot)가 자리를 변경해서 자리를 잡으면 그 기준 원소의 위치는 바뀌지 않습니다.
  - 분할 이후에 해당 피벗을 다시 처리하는 부분 문제는 호출하지 않습니다.

![img](https://user-images.githubusercontent.com/48766355/221349591-e8ddee36-ac25-4d88-8a3b-8ce3dafcc6c5.png)

### 6-8. 다이나믹 프로그래밍 문제에 접근하는 방법

- 주어진 문제가 **다이나믹 프로그래밍 유형임을 파악**하는 것이 중요합니다.
- 가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토할 수 있습니다.
  - 다른 알고리즘으로 풀이 방법이 떠오르지 않으면 다이나믹 프로그래밍을 고려해 봅시다.
- 일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에(탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 코드를 개선하는 방법을 사용할 수 있습니다.
- 일반적인 코딩 테스트 수준에서는 기본 유형의 다이나믹 프로그래밍 문제가 출제되는 경우가 많습니다.

<br />
<hr />
<br />

📚 참고 자료

- [이것이 취업을 위한 코딩 테스트다 with 파이썬](https://product.kyobobook.co.kr/detail/S000001810273)
